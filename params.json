{"name":"Shape-repo","tagline":"Different shapes for use with collision detection","body":"Variety of classes defining different shapes used for collision detection.\r\n\r\n\r\n### CSShape\r\n\r\nDon’t use CSShape directly; it is abstract.\r\n\r\nIf you wish to make a subclass of CSShape, you must override these methods:\r\n```\r\n-[transpose:]\r\n```\r\nwhich takes a CGPoint as an argument and moves\r\nthe shape according to the x and y values of the point.\r\n```\r\n-[pointLiesInside:]\r\n```\r\nwhich returns a boolean that states whether\r\na given point lies inside (or on) the shape.\r\n\r\n```\r\n-[getRandomPoint]\r\n```\r\nwhich returns a random point inside/on the shape.\r\n(This method is optional, it always returns\r\n{0, 0} if you do not override it).\r\n\r\n\r\n### CSShapeGroup\r\n\r\nCSShapeGroup contains an array of shapes that can be\r\ntested against other shape groups. For example, you\r\ncould define a group comprised of two separate circles,\r\nand if either of them trigger a collision, the shape\r\ngroup will detect it.\r\n\t\r\nChange the ‘center’ property to move the shape group.\r\nHowever, shape groups initially start at point {0, 0}.\r\nAll shapes are therefore anchored as they were before\r\nbeing in a shape group. So setting a group’s center to\r\n{20, 20} will change a circle initially centered at\r\n{10, 10} to be centered at {30, 30}.\r\n\r\n\r\n### CSPoint\r\n\r\nCSPoint defines a point in space. CSPoints only\r\ncollide with other shapes if the point lies inside\r\nthe shape (or in the case of a point, they must\r\noccupy the same point).\r\n\r\n\r\n### CSLineSegment\r\n\r\nCSLineSegment defines a line segment. When\r\ninstantiating a line segment, pass in the\r\ntwo endpoints of the line segment.\r\n\r\nThe 'vertical'  property is a boolean that states\r\nwhether the line segment is completely vertical\r\n(it's two points have the same x-values and\r\nthus it has a slope of infinity).\r\n\r\n```\r\n-[getSlope]\r\n```\r\nreturns the slope of the line. If the 'vertical' property\r\nis true (or YES), then it returns 0 (instead of infinity).\r\n```\r\n-[getYIntercept]\r\n```\r\nreturns the y-intercept of the line. If the segment\r\ndoes not cross the y-axis, then it returns the\r\nvalue as if the segment extended that far.\r\n\r\n```\r\n-[getYforX]\r\n-[getXforY]\r\n```\r\nreturn the y-value and x-value for the corresponding\r\nx-value and y-value, respectively. If the given x-value\r\nor y-value is not on the segment, then they return\r\nthe values as if the segment extended to those points.\r\n\r\n### CSRectangle\r\n\r\nCSRectangle defines a rectangle.\r\n\r\nYou can access the line segments that\r\ncomprise the rectangle with\r\n```\r\n-[getLineSegments]\r\n```\r\n\r\n### CSTriangle\r\n\r\nCSTriangle defines a triangle.\r\n\r\nYou can access the line segments that\r\ncomprise the triangle with\r\n```\r\n-[getLineSegments]\r\n```\r\n\r\n### CSCircle\r\n\r\nCSCircle defines a circle.\r\n```\r\n\t-[getPositiveYforX:]\r\n\t-[getNegativeYforX:]\r\n```\r\nreturn the y-value corresponding to the given\r\nx-value. They return 0 if the x-value is invalid.\r\n```\r\n\t-[getPositiveXForY:]\r\n\t-[getNegativeXForY:]\r\n```\r\nreturn the x-value corresponding to the given\r\ny-value. They return 0 if the y-value is invalid.\r\n```\r\n\t-[getPointForAngle:]\r\n```\r\nreturns the point on the circle\r\ncorresponding to the given angle.\r\n\r\n\r\n### CSEllipse\r\n\r\nCSEllipse defines an ellipse (oval).\r\n```\r\n\t-[getPositiveYforX:]\r\n\t-[getNegativeYforX:]\r\n```\r\nreturn the y-value corresponding to the given\r\nx-value. They return 0 if the x-value is invalid.\r\n```\r\n\t-[getPositiveXForY:]\r\n\t-[getNegativeXForY:]\r\n```\r\nreturn the x-value corresponding to the given\r\ny-value. They return 0 if the y-value is invalid.\r\n```\r\n\t-[getPointForAngle:]\r\n```\r\nreturns the point on the ellipse\r\ncorresponding to the given angle.\r\n\r\n#### Note about Ellipses\r\nCollision detection for ellipses against\r\nother ellipses is not quite perfect.\r\n\r\nI’ve yet to find a mathematical formula\r\ndetermining collision detection, so I just test\r\nthe far left, middle, and far right of the\r\noverlapping portions of the ellipse (if the far\r\nleft of the first ellipse is greater than the\r\nfar left of the second ellipse, but vice-versa\r\nfor the far right, then they collide, and etc.).\r\nThis seems to work appropriately, but I'd like\r\nto perfect it.\r\n\r\nIf anyone figures out an exact formula for collision\r\nof two ellipses, then I would gladly update the code\r\nalong with proper attribution.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}